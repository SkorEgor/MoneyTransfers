/********************************************************************************	
*							Зачетная программа									*
*-Ввод из файла данных в динамический массив, состоящий из восьми элементов типа*
*ORDER																			*
*-Упорядочить массив по возрастанию расчетных счетов плательщика				*
*-Ввыод на экран информции о сумме, снятой с расчетного счета плательщика,		*
*введенного с клавиатуры														*
*-Если такого расчетного счета нет, выдать на дисплей соответсвующее сообщение	*
********************************************************************************/

#define _CRT_SECURE_NO_WARNINGS													//Исправление ошибки  _CRT_SECURE_NO_WARNINGS связанная 
																				//с не безопасностью возвращающих указателей 

#include <iostream>																//Подключение файла для потокового ввода и вывода
#include <fstream>																//Подключение заголовочного файла для чтения и для записи данных
#include "Header.h"																//Подключение файла с классом ORDER 

using namespace std;															//Подключение пространства имен std, к которому относится iostream и fstream

// -------------------- Инициализация полей класса ORDER ---------------------- //
ORDER::ORDER()																	//Инициализация конструктор по умолчанию,  
{																				//через присвоение 0-вых значений
	payer_current_account = 0;													//Расчетному счет плательщика, получателя и перечисляемой сумме
	beneficiary_current_account = 0;
	summ = 0;
}

ORDER::ORDER(int p, int b, int s)												//Инициализация конструктор для заполнения скрытых полей/свойств класса, 
{																				//через передачу значений в три временных параметра p,b,c,    
	payer_current_account = p;													//которые являются значениями свойств объекта класса ORDER
	beneficiary_current_account = b;
	summ = s;
}

ORDER::ORDER(ORDER& original)													//Инициализация конструктора копирования
{																				//Используя ссылку на original объект класса ORDER
	payer_current_account = original.payer_current_account;						//Создаем объект с такими же полями
	beneficiary_current_account = original.beneficiary_current_account;
	summ = original.summ;
}

/*void ORDER::print()																//Инициализация метода print
{																				//При при вызове метода, будут выведены скрытые 
	cout << payer_current_account		<< " ; "								//поля/свойства объекта ORDER через точку с запятой
		 << beneficiary_current_account << " ; " 
		 << summ ;
}*/

ORDER& ORDER::operator= (const ORDER& argument)									//Инициализация перегрузки/переопределения операции ПРИСВАИВАНИЯ
{
	payer_current_account = argument.payer_current_account;
	beneficiary_current_account = argument.beneficiary_current_account;
	summ = argument.summ;
	return *this;
}

bool ORDER::operator< (ORDER& argument)											//Инициализация перегрузки/переопределения операции СРАВНЕНИЯ (1) МЕНЬШЕ (2);
{
	return (payer_current_account < argument.payer_current_account);
}

bool ORDER::operator== (int argument)										//Инициализация перегрузки/переопределения операции СРАВНЕНИЯ (1) РАВЕН  (2);
{
	return (payer_current_account == argument);
}

ostream& operator<< (std::ostream& out, const ORDER& x)					//Инициализация перегрузки/переопределения операции вывода, делая функцию 
{																				//вывода <<, дружественной функцией класса ORDER, для доступа к скрытым полям;
	return out	<< x.payer_current_account << " ; "								//Поскольку operator<< является другом класса ORDER, 
				<< x.beneficiary_current_account << " ; " << x.summ;			//то мы имеем прямой доступ к членам ORDER
}																				
// ----------------- Конец инициализации полей класса ORDER ------------------- //


int main()
{
	setlocale(LC_CTYPE, "ru");													//Подключение кирилицы

	int size = 8;																//Задаем длинну масива
	ORDER* mass = new ORDER[size];												//Создаем динамический масссив, для хранения переводов


	// ------------- Вывод данных из файла в динамический массив -------------- //
	ifstream file ;																//класс входных файловых потоков, файловй ввод
	file.open("ReadData.txt");													//Открытие потока с файлом "readme.txt"
	if (!file)																	//Проверка на открытие файла
	{
		cout << "Ошибка открытия" << endl;										//Вывод сообщения об ошибке
	}	
	else																		//Если все хорошо, считываем данные из файла:
	{
		cout << "Наименование столбцов:\n1)Расчетный счет плательщика;\n2)Расчетный счет получателя;\n3)Перечисляемая сумма в рублях." << endl;
		cout << "Сформированный массив из файла:" << endl;
		for (int i = 0; i < size; i++)											//Читаем строчки кол-во которых совпадает с длинной массива
		{																		//По строчно читаем и по одиночно заполняем массив mass
			int file_payer(0), file_beneficiary (0), file_summ (0);				//Создаем переменных для хранения значений суммы, получателя, плательщика 
			file >> file_payer>> file_beneficiary>> file_summ;					//Записываем данные из файла во временные переменных
			mass[i] = ORDER(file_payer, file_beneficiary, file_summ);			//Записываем значение в экземпляр класса ORDER
			cout << mass[i] << endl;											//Проверка полученных данных из файла, с помощью  переопределенной функц. cout
			//mass[i].print();													//Проверка полученных данных из файла, с помощью  метода print
		}
	}
	file.close();																//Закрытие потока
	// -------- Окончание вывода данных из файла в динамический массив -------- //


	// -------------------------- Сортировка массива -------------------------- //
	for (int i = 0; i < size; i++)												//Принцып: Поочередно выбираем ячейки и сравниваем с оставшимися,  
	{																			//в случае нахождения наименьшей меняем их местами.
		ORDER min = mass[i];													//Берем значение выбранной ячеки за нименьшую
		int number = i;															//И сохраняем ее индекс
		for (int u = size - 1; u > i; u--)										//Теперь с конца до нашей ячейки делаем проход на поиск наименьшего значения
		{
			if (!(min < mass[u]))
			{
				min = mass[u];
				number = u;
			}
		}																		
		ORDER kesh (mass[i]);													//Если нашлось значение меньше, то меняем ячейки местами
		mass[i] = mass[number];
		mass[number] = kesh;
	}
	// ---------------------- Окончание сортировки массива -------------------- //


	///*Вывод на экран отсортированного массива
	cout << endl  << "Отсортированный массив:" << endl;							//Создаем отступ и заголовок
	for (int i = 0; i < size; i++)												//Выводим в консоль каждую ячейку массива
	{
		cout<<mass[i]<<endl;													//Проверка  с помощью  переопределенной функц. cout
		//mass[i].print();														//Проверка  с помощью  метода print
	}
	cout << endl;																//Содаем отступ после вывода
	//*/


	// ---- Выввод структуры, заданной пользователем, по расчетному счету ----- //
	int user_input = 0;															//Создаем переменную для хранения искомого расчетного счета введённого пользователем
	cout << "Запрос расчетного счета: ";
	cin >> user_input;															//Записываем введеное значение в переменную, для дальнейшего поиска
	bool flag = true;															//Создаем флаг, если его значение не поменяеться, то рассчетного счета нет												//Создаем объект класса ORDER. с нужным для нас расчетным счетом
	for (int i = 0; i < size; i++)												//Перебираем массив на наличие совпадений
	{
		if (mass[i] == user_input)													//Если совпало, выводим объект и поднимаем флаг
		{
			cout << mass[i] << endl;											
			//mass[i].print();													
			flag = false;
		}
	}
	if (flag) cout << "Расчетный счет не найден" << endl;						//Совпадений нет, выводим сообщение об ошибке
	// --------------------------- Окончание вывода --------------------------- //

	delete[] mass;																//Удаление динамического массива
	system("pause");															//Не дает сразу закрыть окно
}